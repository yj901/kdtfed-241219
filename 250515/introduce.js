/**

1. 자료구조 & 알고리즘 무엇인가?
- 자료구조 : 어떤 데이터(*자료)가 어떤 형태(*구조)로 저장이 되고, 어떻게 사용되는지를 나타내는 것.
- 알고리즘 : 어떤 문제를 해결하기 위한 확실한 해결방법

1. 왜 갈수록 중요해지고 있을까?
- 전공과목 > 지금당장 코드를 작성하는데 큰 영향을 주지 못함
- 비전공자 > 3년차
- 기본코드 > AI가 더 잘 만들어준다

1. 어떤 자료구조와 알고리즘을 사용한느 것이 효과적인가? 를 어떻게 구분하고 판단하나?
- **시간복잡도** (*알고리즘 효율성 측정 척도) 개념 적용
- -시간복잡도 -⇒ 해당 문제를 해결하기 위해서 얼만큼 시간이 걸렸는가
- **코드를 실행하고 결과값을 도출하는데 걸리는 시간.**
- 만약 코드 스타트 → 코드 종료 (*단순 처리시간만 체크) 하면 ⇒ 이 방식은 문제가 있음!
- 순수하게 코드 자체만으로 해당 코드의 효율성을 측정해야 할 필요가 존재.
- 코드를 보고, 코드 안에 어떤 문제를 해결하는데 있어서 가장 많은 시간을 소비할 것으로 판단되는 요소의 실행 횟수 및 갯수
- **반복문**의 대한 효율성. 시간복잡도 차이가 확 벌어지는 부분. 
반복문을 효율적으로 잘 쓴다 → 이터러블한 객체에 대한 이해가 높다 → 클래스에 대한 이해가 높다는 것.

*/
//배열에서 5를 찾는 예쩨

const arr01 = [1, 3, 5, 7];

// 5라는 숫자를 상기 배열에서 찾을 수 있는 경우의 수

// 1. 반복문이 실행된 이후 바로 찾는 경우 ⇒ 빅오메가
// 2. 반복문이 실행된 이후 모든 배열요소를 순회하고 가장 마지막 번째에 찾는 경우 ⇒ 빅오
// 3. 반복문이 실행된 이후 배열 요소의 절반 정도만 순회하고 찾는 경우 ⇒ 빅세타

// **빅오**의 단계에 접어들었을 때 시간복잡도의 값을 인정.

// 시간복잡도 예시1
const addUpto1 = (n) => {
  return (n * (n + 1)) / 2;
};
// 덧셈 연산 1회
// 곱셉 연산 1회
// 나눗셈 연산 1회
// 세번의 연산이 일어남
// 빅오(3)

//시간복잡도 예시2
const addUpto2 = (n) => {
  let total = n;
  for (let i = 0; i < n; i++) {
    total += i;
  }
  return total;
};
//total 변수 선언 및 값 할당 1회
// i 변수 선언 및 값 할당 1회
// i와 n의 비교 n회
// i 덧셈 n회
// i 증가 n회
// i 할당 n회
// 5n + 2 회
// 10줄 대입 -> 50 + 2 = 52
// 빅오(5n)

/*
### 빅오 표기법

코테에서 코드 짜고 이 코드의 시간복잡도 쓰기. 빅오. 계산할 줄 알아야함.

이 코드에서 시간을 제일 잡아먹는 연산은 이거. 이거의 시간복잡도는 이거. 

### 빅오를 활용한 시간복잡도의 종류

상수 n이 8이다 가정하고?

1. 상수시간 복잡도 : 빅오 인자값으로 들어가는 값이 상수. 빅오(8) 
2. 로그시간 복잡도 :  log₂n → 빅오(n)
3. 선형시간 복잡도 : 그래프에서 밑에 있을수록 효율, 위로 올라갈수록 비효율.(상수 / 팩토리얼n!)
4. 다항시간 복잡도 : 

무조건 빅오(8)이라면서 왜 상수1? 빅오1???

---

log 로그. 제곱근을 효율적으로 계산하는 것.

간소화. 작은 값을 가지고도 큰 값을 계산할 수 있게 됨. 

log₂8 → 빅오(3)

로그는 2진.
*/

/*
### 배열 vs 연결리스트 (직접 클래스를 통해 만드는 것)

자바스크립트 배열 ⇒ 특수함!

컴퓨터 내 메모리공간 자유롭게 사용할 수 있도록 설계

자바의 배열 

int arr[10]  배열 안에 들어가는 값의 갯수와 타입을 정함. (js의 튜플과 같음)

컴퓨터 > 메모리공간 > 자료생성

모든 자료의 형태 & 개수 미정

연결리스트

입출력이 빈번하게 일어나야 하면 배열 대신 연결리스트.

근데 관공서 등 데이터의 입출력이 잦지 않고 필요할때만 가져가서 쓸거면 배열.

**데이터의 입출력의 빈도에 따라서 잦으면 연결리스트, 아니면 배열을 사용.**
*/

/*

### 자주 빈번하게 사용하는 연결리스트 타입 7개  ⇒ 추상자료형 (ADT)

1. `printAll()`
2. `clear()`
3. `insertAt()`
4. `insertLast()`
5. `deleteAt()`
6. `deleteLast()`
7. `getNodeAt()`

⇒ 7개의 함수를 구현할 수 있도록 생성된 자료구조 형태 : 추상자료형 이라고 부름

***ADT** **A**bstract **D**ata **T**ype
*/
