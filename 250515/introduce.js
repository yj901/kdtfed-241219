/*

1.자료구조 & 알고리즘 무엇인가?
- 자료구조 : 어떤 데이터(*자료)가 어떤 형태(*구조)로 저장이되고, 어떻게 사용되는지를 나타내는 것 => 아마추어 // 프로
- 알고리즘 : 어떤 문제를 해결하기 위한 확실한 해결방법

2. 왜 갈수록 중요해지고 있을까?
- 전공과목 > 지금당장 코드를 작성하는데 큰 영향을 주지 못함
- 비전공자 > 3년차
- 기본코드 > AI가 더 잘 만들어준다

3. 어떤 자료구조와 알고리즘을 사용하는 것이 효과적인가?를 어떻게 구분.판단?
- 시간복잡도(*알고리즘 효율성 측정 척도) 개념 적용
- 시간복잡도 => 해당 문제를 해결하기 위해서 얼만큼 시간이 걸렸는가
- 코드를 실행하고 결과값을 도출하는데 걸리는 시간
- 만약 코드 스타트 => 코드 종료 (*단순 처리시간만 체크) => 이 방식으로는 문제가 있다!!!
- 순수하게 코드 자체만으로 해당 코드의 효율성을 측정해야할 필요 존재
- 코드를 보고, 코드 안에 어떤 문제를 해결하는데 있어서 가장 많은 시간을 소비할 것으로
판단되는 요소의 실행 횟수 및 개수
- 반복문을 활용해서 반복을 많이 하면 할 수록 문제를 처리하는데 소요되는 시간은
많아질것이고, 그만큼 코드의 효율성은 떨어질 수 밖에 없다!!!

*/

// ex.1
const a = 87;
const b = 70;
const c = 100;

const average = (a + b + c) / 3;
console.log(average);

// ex.2
const arr = [87, 70, 100];

let average01 = 0;

for (let i = 0; i < arr.length; i++) {
  average01 += arr[i];
}

average01 /= arr.length;

console.log(average01);

// ex.3
// 아래 주어진 배열에서 5를 찾아보세요!!!

const arr01 = [1, 3, 5, 7];

// 5라는 숫자를 상기 배열에서 찾을 수 있는 경우의 수
// 1.반복문이 실행된 이후에 바로 찾는 경우 => 빅오메가
// 2.반복문이 실행된 이후에 모든 배열 요소를 순회하고 가장 마지막 번째에 찾는 경우 => 빅오
// 3.반복문이 실행된 이후 배열 요소의 절반 정도만 순회하고 찾는 경우 => 빅세타

// 시간복잡도 예시1
// 덧셈 연산 1회
// 곱셈 연산 1회
// 나눗셈 연산 1회
// 빅오(3)

const addUpTo1 = (n) => {
  return (n * (n + 1)) / 2;
};

// 시간복잡도 예시2
// total 변수 선언 및 값 할당 1회
// i 변수 선언 및 값 할당 1회
// i 와 n의 비교 n회
// i 덧셈 n회
// i 할당 n회
// i 증가 n회
// i 할당 n회
// 5n + 2 회
// 10을 대입 => 50 + 2 = 52
// 빅오(5n)

const addUpTo2 = (n) => {
  let total = n;
  for (let i = 0; i < n; i++) {
    total += i;
  }
  return total;
};

// 빅오를 활용한 시간복잡도의 종류
// 1. 상수시간 복잡도 : 빅오 인자값으로 들어가는 값이 상수 빅오(8)
// 2. 로그시간 복잡도
// 3. 선형시간 복잡도
// 4. 다항시간 복잡도

// 배열 VS 연결리스트

// 자바스크립트 배열 => 특수함!!!
// 컴퓨터 내 메모리공간 자유롭게 사용할 수 있도록 설계
// int arr[10] => int arr[20] // int arr[3]
// number, number, number[]
// 컴퓨터 > 메모리 공간 > 자료생성
// 모든 자료의 형태 & 개수 미정

// 연결리스트가 무엇인지 살펴보았음!!!

// 자주 빈번하게 사용하는 연결리스트 종류타입
// 아래 7개의 함수를 구현할 수 있도록 생성된 자료구조 형태
// 추상자료형 (*ADT) => Abstract Data Type
/*
1) printAll()
2) clear()
3) insertAt()
4) insertLast()
5) deleteAt()
6) deleteLast()
7) getNodeAt()
*/

/*

스택(*Stack) => LIFO
- 데이터를 쌓아올리는 형태의 자료구조
- Last In First Out
- 생활에서 만날 수 있는 스택형식의 상황 : 설거지 // 엘리베이터
- 배열 혹은 연결리스트를 활용해서 스택 자료구조 생성 가능!!

만약, 연결리스트를 활용해서 스택의 자료구조를 생성한다면?
- 데이터 삽입을 무조건 첫 번째 인덱스로만 실행을 해주면 가능!
- 데이터 제거를 무조건 첫 번째 인덱스에서만 실행을 할 수 있게 해주면 가능!

스택형식의 자료구조를 띄고 있는 연결리스트의 추상자료형 데이터 타입기능을 생성
1) push() : 데이터 삽입
2) pop() : 데이터 제거
3) peek() : 데이터 참조
4) isEmpty() : 데이터존재 여부확인

- 스택은 데이터가 이동하는 방향은 반드시 1개의 방향으로 진행 (*원칙)

*/

/*

큐(*Queue) => FIFO
- First In First Out
- 일상생활에서 만날 수 있는 큐의 자료구조 형태 : 마트 줄서기, 식당 음식 주문, 놀이동산 => 놀이기구 탑승 대기
- 스택과 동일하게 큐 역시 데이터가 이동하는 방향을 1개의 방향으로 설정할 수도 있지만, 만약 그랬을 경우, 빅오표기법을
통한 시간복잡도의 경우 선형빅오표기법 형식의 비효율성이 도출될 수 있음!!!
- 따라서 스택과 달리 next 방향 뿐만 아니라, prev 방향 역시 필요함!!!

입구 (*head)
출구 (*tail)

큐의 자료구조를 띄고 있는 연결리스트의 추상자료형 데이터 타입기능을 생성
1) enqueue() : 데이터 삽입
2) dequeue() : 데이터 제거
3) front() : 데이터 참조
4) isEmpty() : 데이터존재 여부확인

덱(*Deque)
- head에서 삽입 뿐만 아니라, 제거도 가능!
- tail에서 제거 뿐만 아니라, 삽입도 가능!

덱의 자료구조를 띄고 있는 연결리스트의 추상자료형 데이터 타입기능을 생성
1) printAll() : 모든 데이터 출력
2) addFirst() : head에 데이터 삽입
3) removeFirst() : head에 데이터 제거
4) addLast() : tail에 데이터 삽입
5) removeLast() : tail에 데이터 제거
6) isEmpty() : 리스트 비어있는 여부 체크

해시테이블 (*HashTable)
- 다양한 데이터들의 반복적인 공통 패턴을 찾아서 테이블 안에 효율적으로 관리.보관하고자 개발된 자료구조형태

- 장점 : 데이터를 효율적으로 검색, 읽기, 쓰기, 삭제
- 단점 : 해시 함수의 영향을 절대적으로 받는다

1) set : 해시테이블 데이터 삽입
2) get : 해시테이블 데이터 읽기
3) remove : 해시테이블 데이터 삭제

해시셋 (HashSet)
- 연결리스트 형식의 데이터를 생성해야하는 데, 내부에 데이터의 중복값을 허용하지 않는 자료구조

1) add(data) : 데이터 삽입
2) isContain(data) : 데이터 체크
3) remove(data) : 데이터 제거
4) clear() : 셋 비우기
5) isEmpty() : 셋이 비었는지 체크
6) printAll() : 모든 데이터 출력

*/
